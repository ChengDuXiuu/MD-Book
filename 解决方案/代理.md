## 为什么出现代理

比如：有一个类，功能是出售房子。如果我们想要在出售方子前加一些验证：校验买方信息的真实性。

*   我们最容易想到的就是在出售房子方法中硬编码加入校验功能。但是这样的话就违背了单一性原则和开闭原则。
*   我们使用工具类或者父类封装校验方法，但是如果通过工具类则会污染业务代码，如果是通过类继承，则会影响其他父类的继承。

>   因此使用代理类，在代理函数前进行校验。总之，一句话，代理能够进行方法增强，也是切面编程的实现原理。

```java
/*
 * @Author No1.shuai
 * @Description //TODO 代理出现原因
 * @Date 17:26 17:26
 **/
@Slf4j
@Component
public class Cause {
    @Autowired(required = false)
    private Medium medium;

    public void sellHouse(){
        /* 验证 */
        log.info("买方信息真实，可以进行卖出！！");

        medium.sellHouse();

        log.info("交易结束！！");
    }

}

@Component
class Medium{
    //卖房子
    public void sellHouse(){
        System.out.println("卖房子！！");
    }
}
```

```java
@Configuration
@ComponentScan(basePackageClasses = {Cause.class,Medium.class})
public class AnnotationScanConfig {

}
```

```java
@RunWith(SpringRunner.class)
@ContextConfiguration(classes = AnnotationScanConfig.class)
public class Client {
    @Autowired
    private Cause cause;

    @Test
    public void proxy(){
        cause.sellHouse();
    }
}
```

```bash
17:54:28.493 [main] INFO com.shuai.springaop.proxy.Cause - 买方信息真实，可以进行卖出！！
卖房子！！
17:54:28.493 [main] INFO com.shuai.springaop.proxy.Cause - 交易结束！！
```



## 代理分类

参考 ：MD-Book\Java高级\Java-设计模式\第十三节-代理模式.md



*   静态代理
*   JDK动态代理
*   cglib代理

