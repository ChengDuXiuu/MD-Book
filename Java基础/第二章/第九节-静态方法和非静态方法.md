### 一、静态方法，非静态方法常驻内存？
一般都认为是这样，并且怕静态方法占用过多内存而建议使用非静态方法，其实这个理解是错误的。静态方法和非静态方法，他们都是在第一次加载后就常驻内存，所以方法本身在内存里，没有什么区别。

### 二、下静态方法和非静态方法的区别
在内存中的区别是：

非静态方法在创建实例对象时，因为属性的值对于每个对象都各不相同，因此在new一个实例时，会把这个实例属性在GC Heap（堆内存）里拷贝一份，同时这个new出来的对象的引用放在堆栈上，堆栈指针指向了刚才拷贝的那一份实例的内存地址上。

静态方法则不需要，因为静态方法里面的静态字段，就是保存在Method Table(方法区)里了，只有一份。

因此静态方法和非静态方法，在调用速度上，静态方法速度一定会快点，因为非静态方法需要实例化，分配内存，但静态方法不用，但是这种速度上差异可以忽略不计。

###三、为什么要有非静态方法？
早期的结构化编程，几乎所有的方法都是“静态方法”，引入实例化方法概念是面向对象概念出现以后的事情了，区分静态方法和实例化方法不能单单从性能上去理解，创建c++,java,c#这样面向对象语言的大师引入实例化方法一定不是要解决什么性能、内存的问题，而是为了让开发更加模式化、面向对象化。这样说的话，静态方法和实例化方式的区分是为了解决模式的问题。

接下来继续思考，如果我们全部用静态方法，不用非静态方法，不是一样能实现功能吗？是的，没错，但是你的代码是基于对象，而不是面向对象的，因为面向对象的继承和多态，都是非静态方法。

第二个原因是为什么不建议都用静态方法，我们如果多线程的情况下，如果静态方法使用了一个静态字段，这个静态字段可以会被多个线程修改，因此说如果在静态方法里使用了静态变量，这就会有线程安全问题，当然了，就算不是多线程，因为静态字段只有一份，同样会有被其他地方修改的问题。
