## 场景

修改用户状态，状态信息存放在内存中。

1. 内存中查询状态信息。
2. 然后修改内存状态
3. 写入到内存中

> 当jvm锁因为分布式出现问题的时候就可以使用分布式锁了。

## 问题

并发不高的情况下，逻辑没有问题。

并发上来后，就会出现状态信息对不上的情况



## 解决

### 解决一

jvm锁，在单体应用中没有问题，顶多就是并发性能问题。

> 在**分布式**中就会存在问题，因为jvm锁只能锁住当前jvm进程。



### 解决二

分布式锁，即利用Redis提供的setnx命令特性【没有key则返回true，有则返回false】以及Redis的单线程特性。

> 就好比萝卜坑（key）一样，分布式应用中线程进来先看下redis中这个坑是否被占用，如果占用则线程阻塞或者自旋，等待坑被del。

但是有个问题，就是**死锁**问题，即因为死机或者代码问题导致del没有被执行，导致其他线程抢不到锁（占不到坑位）。

### 解决三

分布式锁 + try finally。在finally中执行del。但是还存在执行finally时电脑宕机情况，导致**死锁**。虽然这种情况概率极低，但是要提高程序的高可用，我们必须考虑这种情况。

<font color=ff00aa>应付一般场景足矣，除非成千上万的并发在使用如下解</font>

### 解决四

分布式锁 + try finally + ttl，为 锁|坑|key 设置过期时间。完美解决死锁问题，但是当业务超时因为卡顿或者数据量大导致**超时，产生释放其他线程锁**的问题。



### 解决五

分布式锁 + try finally + ttl + uuid，即上锁除了要设置ttl还要将值设置为uuid，当释放锁时判断是否为当前uuid，是则释放，不是则不释放。

但是如果在判断为true并且要**释放锁之前卡顿超时导致锁释放错误**怎么办？



### 解决六

 分布式锁 + try finally + ttl + uuid + 事务，解决如上问题。

使用Redis事务，存在**事务并发冲突**问题，当事务冲突后，后面的事务将不执行，更要命的是Redis事务保证了原子性和一直性，但是不能回滚。一般中很少使用事务



### 解决七

使用分布式锁 + try finally + ttl + uuid + lua脚本。借住lua脚本完美解决事务问题，使用分布式锁技术框架 --  **redisson**，其拥有看门狗和自动续期特性完美解决死锁以及事务冲突问题，并且还提供了各种类型的锁机制，以便使用不同的业务场景

> 详情参考 ： MD-Book/Redis/第十四章-Redis使用场景.md