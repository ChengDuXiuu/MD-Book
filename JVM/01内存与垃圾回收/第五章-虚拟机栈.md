`引言:`

​	上一章讲到，PC寄存器能够  为 `执行引擎` 在多线程情况下提供 每个线程 下一个`要执行的JVM指令`的地址。其中有几个重要的点：

* 类加载子系统：翻译为字节码文件(由PC寄存器偏移量和JVM指令集命令组成)
	* 类加载器以及  类加载、连接、初始化
	* 双亲委派机制
* class字节码中内容：偏移地址和操作指令
* 局部变量表：存放方法变量，方法内有效
* JVM指令集架构和常见指令
* 执行引擎



## 虚拟机栈

### 1、虚拟机栈中数据结构

* 堆

	存储单位，解决数据存储的问题，即数据怎么放，放哪里

* 栈

	运行时单位，解决程序运行时问题，即如何处理数据



### 2、是什么

Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。`每个线程`在创建时都会创建一个虚拟机栈，`用以保存运行时方法相关数据`，其内部保存一个个的`栈帧（Stack Frame）`，对应着一次次的`Java方法调用`。

* 基本单位为栈帧，一个栈帧对应一个方法调用。
* 栈顶存放的是当前方法调用
* 线程私有，生命周期和线程生命周期同步，线程安全：线程独有
* 只有进栈和出栈操作，运行速度次于PC寄存器

![image-20210421221833734](第五章-虚拟机栈.assets/image-20210421221833734.png)





### 3、作用

`主管Java程序的运行`，它保存方法的局部变量、部分结果，并参与方法的调用和返回。



### 4、栈中异常

* Java 虚拟机规范允许Java栈的大小是`动态`的或者是`固定不变`的。

	* 默认 -Xss为1024kb，即1MB

	* 手动调整栈大小

		```bash
		-Xss1m
		-Xss1k
		```

* 如果一个方法死循环，不停的创建局部变量等`栈帧`，从而会导致`局部变量表`等内存空间占满。即使手动调整后，StackoverflowError虚拟机栈溢出异常也是迟早问题。

	```java
	public class StackErrorTest {
	    private static int count = 1;
	    public static void main(String[] args) {
	        System.out.println(count++);
	        main(args);
	    }
	}
	// 1. Java文件通过类加载器 经过(加载--链接[验证、准备、解析]--初始化)编译为class字节码文件：PC寄存器偏移量  和   jvm指令
	// 2. 其中 【解析】就是负责将常量池中符号引用变为直接引用。 其中常量池 就 包含在 class字节码中。而#4 等都是符号引用。#4后面的地址为直接引用
	// 3. 将class字节码文件 加载进入jvm内存。
	// 4. 执行引擎 使用class字节码信息时操作时，比如new对象等操作，会进一步解析 class 字节码信息。为运行做准备。这个时候引入了 运行时数据区。
	// 5. 主线程创建、main函数执行，随着主线程创建，虚拟机栈创建
	// 6. 执行引擎 根据PC寄存器偏移量  一步一步执行 class字节码中的jvm指令。其中main函数中不停迭代，args变量同时在局部变量表中不停的创建【load和store指令不停切换执行】，从而导致虚拟机栈溢出StackoverflowError
	```



### 5、虚拟机栈存储单位以及存储内容

`单位` ： 栈帧。

* 栈帧是一个数据集，维系这`方法执行`过程中各种数据信息
* 一个栈帧对应一个方法。
* 每个线程都有自己的虚拟机栈
* 栈顶栈帧为当前活动方法
* 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。
* 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。

> 栈帧的大小主要由局部变量表 和 操作数栈决定的

![image-20210421225411636](第五章-虚拟机栈.assets/image-20210421225411636.png)

`存储内容 即 栈帧包含内容`

1. 局部变量表（Local Variables）：<font color=ffaa00>存储方法中局部变量的一个数组</font>
2. 操作数栈（operand Stack）（或表达式栈）：<font color=ffaa00></font>
3. 动态链接（DynamicLinking）（或指向运行时常量池的方法引用）：<font color=ffaa00></font>
4. 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）：<font color=ffaa00></font>
5. 一些附加信息 ：<font color=ffaa00></font>

> 栈帧的大小主要由`局部变量表` 和 `操作数栈`决定的，栈帧生命周期由当前方法调用是否结束来决定

![image-20210421225555254](第五章-虚拟机栈.assets/image-20210421225555254.png)

#### 1、局部变量表

*   `存放线程在当前方法执行过程中依然有效的局部变量`，建立在`虚拟机栈`上，属于栈帧，即线程私有，线程安全。`生命周期 随着当前方法调用结束(栈帧)结束而销毁`

*   是一个`数字数组`，用来保存`方法参数`或者方法体内的`局部变量`，便于`方法在执行过程`中`执行引擎数`据相关的操作。其类型可以是 `基本数据类型`、`引用类型`
*   局部变量表 所需大小 在编译期间就已确定，因此如果线程中方法 参数或者局部变量居多，会存在栈溢出 异常。

`槽 solt`

​	**为什么有槽的概念**

​		局部变量表 中 存放Java基本类型、引用类型数据。而各种数据长度不一致。因此引出槽的概念，节省内存。

​	**是什么**

*   局部变量表，最`基本的存储单元是Slot（变量槽）`局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference）.

*   在局部变量表里，`32位(字节数*8)以内的类型只占用一个slot`、`64位(字节数*8)的类型（1ong和double）占用两个slot`。

    >   byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。 long和double则占据两个slot。

*   普通方法中 第一行 默认存放当前对象引用，静态方法中没有，也不需要直接对象 .
*   JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值

![image-20210422193426574](第五章-虚拟机栈.assets/image-20210422193426574.png)

>   其中 long 和 double占了两个 slot，因此 访问索引加+1

`槽slot 重复利用`

栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。`比如，methodA 调用 methodB。B调用结束后，栈帧中局部变量表中槽slot已经创建，并且B中局部变量已销毁，此时空缺出来的槽 可以给A中调用B之后创建的局部变量使用。`或者如下，代码块方式：

![image-20210422194051590](第五章-虚拟机栈.assets/image-20210422194051590.png)



`变量的分类：`

-   按数据类型分：基本数据类型、引用数据类型
-   按类中声明的位置分：成员变量（类变量，实例变量）、局部变量
    -   类变量：linking的paper阶段，给类变量默认赋值/静态常量显示赋值，init阶段给类变量显示赋值
    -   实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值
    -   局部变量：在使用前必须进行显式赋值，不然编译不通过。

#### 2、操作数栈

每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 **操作数栈**，也可以称之为 **表达式栈**（Expression Stack）

操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）

-   某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈
-   比如：执行复制、交换、求和等操作

![image-20210422194531980](第五章-虚拟机栈.assets/image-20210422194531980.png)

操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。