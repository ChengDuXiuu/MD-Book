## 作用

> PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。

首先要清楚三个概念

* 串行：依次执行。
* 并发：
	* 例如CPU单核就是并发，怎么理解呢。面对大量处理任务，CPU时间分片，即一段时间处理任务A、一段时间处理任务B、另一端时间处理任务C ，以此循环往复。
	* 例如我么常说的高并发，即请求暴增的情况下。所有的请求几乎同时到达后台，后台即便使用多线程为每个请求创建一个线程去处理，但是到CPU单核这里也是例如上面一样并发处理多个线程
* 并行：多核CPU同步处理多个任务



> * 多线程下，CPU是并发执行，因此需要在线程切换后再切回来时有记录执行到哪一步`jvm指令：见附录一`，然后继续执行。类似于硬件寄存器。PC寄存器是软件层面的寄存器。
> * Java整个语言中，首先java文件编译为class字节码文件，其中字节码文件存放的便是 Java语言 对、≥≤应的 `jvm指令`。然后进入内存 由`执行引擎`  编译  为   `机器指令` 交由CPU执行。并不是所有的命令都会编译为机器码，只有逻辑运算需要用到CPU处理的指令才会编译为机器码

*​*:hamster:**查看CPU核心数**

![image-20210419140734402](第四章-PC寄存器(程序寄存器).assets/image-20210419140734402.png)





## 介绍

* 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。

* 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。

* 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。

* 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

* 它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。
* `既不存在GC,也不存在OOM`



## 流程

```java
public class PCRegisterTest {
    static final String ss = "TEST"; //准备阶段 ：显示初始化
    static String sss;//准备阶段 ：默认值初始化
    static {
        sss = "短发";
    }
    public static void main(String[] args) {
        int i = 10;
        int j = 20;
        int k = i + j;
        System.out.println(k);
        String str = "hello world";
        System.out.println(str+"  "+sss);
    }
}
```



![image-20210419160713116](第四章-PC寄存器(程序寄存器).assets/image-20210419160713116.png)



![image-20210419161129235](第四章-PC寄存器(程序寄存器).assets/image-20210419161129235.png)

![image-20210419162138664](第四章-PC寄存器(程序寄存器).assets/image-20210419162138664.png)

`解读:`

* 偏移地址0      ：将 值`10`放入 `操作数栈` 【10为基本数据类型直接存储在栈中】
* 偏移地址2      ：将 `10 `存入局部变量表  `istore_1`
* 偏移地址3      ：将 值`20`放入 `操作数栈` 【20为基本数据类型直接存储在栈中】
* 偏移地址5      ：将 `20` 存入局部变量表  `istore_2`
* 偏移地址6、7 ：将  10  和  20  从`局部变量表`中加载到`操作数栈`，数据准备后操作的前奏。
* 偏移地址8      ：10   20   加法运算
* 偏移地址9      ：将`运算后值` 存入局部变量表 ` istore_3`
* 偏移地址10     ：从常量池中获取  `#2` 信息。即System IO流
* 偏移地址13     ：从局部变量表中加载  `iload_3` 值（即10和20 add后值）放入到`操作数栈`
* 偏移地址14     ：从常量池中 获取 `#3`信息，即System IO流  并输出 `操作数栈`中的 `iload_3 `值
* 偏移地址17     ：从常量池中 获取 `#4`信息，即字符串**hello world** 存入到栈顶
* 偏移地址19     ：将字符串**hello world** 的`引用`存入到局部变量表  `astore_4`
* 偏移地址21     ：从常量池中获取  `#2` 信息。即System IO流
* 偏移地址24     ：new 一个”    “三个空格的字符串
* 偏移地址27     ：从栈顶拷贝一个栈顶元素副本 即复制一份 **hello world** 
* 偏移地址28     ：从常量池中调用 `#6` #6-->#5和#39   其中#5-->#45 为StringBuilder 
* 偏移地址31     ：将 astore_4 即字符串**hello world** 加载到`操作数栈`
* 偏移地址33     ：调用方法 StringBuilder 
* 偏移地址36     ：将常量池中 `#8`指向 ”    “字符串放入栈顶
* 偏移地址38     ：调用方法 StringBuilder 
* 偏移地址41     ：将常量池中 `#9`指向类变量 sss 字符串放入栈顶
* 偏移地址44     ：调用方法 StringBuilder 
* 偏移地址47     ：将栈顶元素 调用 toString方法
* 偏移地址50     ：输出内容
* 偏移地址53     ：返回

> load ：执行逻辑操作的前奏，其余命令均为数据准备，栈管运行，堆管存储

> :zap: PC寄存器主要负责 记录线程操作命令偏移数。其操作方为 `执行引擎` ：根据PC寄存器中jvm指令  以及常量池中数据或者局部变量表以及操作数栈进行操作，并翻译为机器码交给CPU执行，如下图

![image-20210419170051181](第四章-PC寄存器(程序寄存器).assets/image-20210419170051181.png)



## 问题

1. PC寄存器为什么被设定为私有

	如果不是线程私有，则需要为每个线程提供 key-value数据结构来保存每个线程其对应的操作行



2. 为什么要使用PC寄存器

	多线程下，因为CPU的时间片切换，每个线程需要轮流执行、来回切换，因此需要有一个东西来记录下次jvm命令的地址，从而继续执行



## PC寄存器中异常

无异常、无GC。

> 只保存了下一条jvm指令的内存地址。



## 附录一：jvm指令

见 ：MD-Book/JVM/02字节码与类加载/第二章-字节码指令.md