## 锁升级

详情见 MD-Book/Java高级/Java多线程/知识点/temp.md  这里是指梳理下使用流程



`ThreadLocal`

* 不满足  JMM -- 原子性
* 不满足  JMM -- 有序性
* 不满足  JMM -- 可见性

> 只是给每个线程维护一个副本
>
> 适用于 无状态  的全局变量
>
> <font color=ff00aa>根本不能够保证线程安全</font>





`Volatile`

- 满足  JMM -- 有序性
- 满足  JMM -- 可见性
- 不满足  JMM -- 原子性

> 适用于 一读多写的场景   用了可见性
>
> 适用于 避免指令重排(DCL)  用了有序性
>
> <font color=ff00aa>还是不能够保证线程安全</font>





`原子类`

- 满足  JMM -- 有序性
- 满足  JMM -- 可见性
- 满足  JMM -- 原子性

> 无锁结构、利用了CAS原理   并且解决了ABA问题。
>
> 适用于 轻量级线程安全 或者说适用于自增以及bool等







`Lock`

- 满足  JMM -- 有序性
- 满足  JMM -- 可见性
- 满足  JMM -- 原子性

> 重量级锁、操作更加灵活(显式锁)
>
> 适用于 轻量级线程安全





`Synchorized`

- 满足  JMM -- 有序性
- 满足  JMM -- 可见性
- 满足  JMM -- 原子性

> 重量级锁，但是在JDK1.6后 引入了锁升级，可放心大量食用



## 锁升级

`无锁`

如果一个对象中对象头所标志位正常则该对象无锁，比如一些利用操作系统原语比如CAS去实现或者是 copyorwriteArrayList 利用每次add时则进行拷贝一份将旧引用重新指向新引用，然后读取时使用原先变量

==threadLocal==、==Volatile==、==原子类==

`偏向锁`

在 Synchronized 锁升级中出现，在锁无竞争的情况下完全取消同步，都是乐观锁





`轻量级锁`









`重量级锁`

Synchorized 和 lock  全程上锁，适用于锁竞争激烈的情况





`读写锁`

Volatile 适用于 一个线程操作，多个线程读取。无法解决 少许线程操作多数线程读取情况。并且需要一个轻量级的，因此出现了读写锁，即度多写少