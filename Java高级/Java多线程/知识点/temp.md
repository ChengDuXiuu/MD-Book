## Synchorized  有锁

*   隐式锁、悲观锁、互斥锁
*   jdk1.6重量级锁，1.6之后进行了锁升级
*   同步方法、同步代码块
*   依赖于系统 监视器 Mointor jvm两个指令 和对象头中的     无锁、偏向锁、轻量级锁、重量级锁     | 自选锁   适应式自旋锁
*   保证原子和可见
*   适用于线程激烈竞争锁资源的情况



## Lock  有锁

*   显示锁、互斥锁、乐观锁基于CAS和AQS
*   操作更加灵活、必须手动释放
*   保证原子和可见
*   适用于竞争不那么激烈的情况，因为其使用了CAS实现



## 原子类  无锁

`为什么有了 Synchorized  和  Lock还要研发原子类等无锁机制？`

>   Synchorized 和 Lock 都是偏重量级锁，我们想要一个更好的，更轻量的 ，资源占用更少一个方案去解决线程安全问题

*   CAS实现

*   适用于 自增或者操作简单的场景或者说是竞争不激烈的场景  【为了实现一个i++保证线程安全】完全没有必要使用锁机制去线程安全
*   还有他的 更新boolean 等非常适合和 信号量搭配 





## Volatile  无锁

*   保证变量在多线程中可见性，但是不能保证原子性
*   Volatile 只能使用一个变量，否则无效
*   适用于DCL和一个写多个读线程



## ThreadLocal

*   并不去解决线程安全，和Volatile类似
*   只是 去为每一个使用该变量的线程创建一个副本
*   适用于 无状态的全局变量