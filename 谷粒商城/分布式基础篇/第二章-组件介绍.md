## 为何有这么多组价

> 组件的出现就是为了管理多个微服务并且解决微服务中出现的问题。

`问题:`

* 不同的服务之间如何调用？
* 这么多服务如何集中管理？
* 这么多服务如何对外提供访问？
* 微服务崩了如何治理？





`解决:`

* 远程调用 | 负载均衡
	* RPC
	* HTTP
* 服务注册与发现
	* Eureka
	* Nacos
	* Zookeeper
* 网关
	* Gateway
	* Zuul
* 服务熔断降级以及链路追踪
	* Hystrix
	* Envoy





## 远程调用 | 负载均衡

> 讲到远程调用必定有负载均衡，如果火爆业务不做负载均衡，那么系统的可靠性将大大降低。一般用Nginx作负载均衡服务器。在微服务中使用服务注册发现即可，它可以帮助我们更好地管理服务及服务集群。

### RMI

`含义:`

==远程方法调用==，能够让在客户端的Java虚拟机上的对象调用本地对象一样调用服务端Java虚拟机中的对象上的方法。只限于Java语言。



`工作流程:`

1. 服务端向 RMI 注册服务绑定自己的地址；register
2. 客户端通过 RMI 注册服务获取目标地址；subscribe+notify
3. 客户端调用本地的 Stub 对象上的方法，和调用本地对象上的方法一致；
4. 本地存根对象将调用信息打包，通过网络发送到服务端；
5. 服务端的 Skeleton 对象收到网络请求之后，将调用信息解包；
6. 然后找到真正的服务对象发起调用，并将返回结果打包通过网络发送回客户端。



`特点:`

* 通过接口进行远程方法调用
* 通过客户端的 Stub 对象和服务端的 Skeleton 对象的帮助将远程调用伪装成本地调用
* 通过 RMI 注册服务完成服务的注册和发现
* 调用结果可以是对象类型也可以是基本数据类型



`缺点:`

* 只适用于Java
* 底层是BIO、而不是NIO
* 底层序列化使用的是JDK序列化机制，效率不高
* 注册中心是单点的，挂了的话整个系统不可用



> 一般不直接使用RMI作远程调用





### RPC

`含义:`

是一个==计算机通信协议==。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。说得通俗一点就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。



`工作流程:`

 1. 调用者（客户端Client）以本地调用的方式发起调用；

 2. Client stub（客户端存根）收到调用后，负责将被调用的方法名、参数等打包编码成特定格式的能进行网络传输的消息体；

 3.  Client stub将消息体通过网络发送给服务端；

 4. Server stub（服务端存根）收到通过网络接收到消息后按照相应格式进行拆包解码，获取方法名和参数；

 5. Server stub根据方法名和参数进行本地调用；

 6. 被调用者（Server）本地调用执行后将结果返回给server stub；

 7. Server stub将返回值打包编码成消息，并通过网络发送给客户端；

 8. Client stub收到消息后，进行拆包解码，返回给Client；

 9. Client得到本次RPC调用的最终结果。

	

`特点:`

* 自定义数据格式(通信双方约定好格式)。
* 是一种通信协议，适用于不同的语言
* 基于原生TCP(可靠)通信，速度快，效率高(二进制传输)。
* 早期的webservice，现在热门的dubbo，都是RPC的典型



`缺点:`

* 几乎无缺点
* 学习开发难度大



### HTTP

`含义:`

超文本传输协议，是一种==应用层协议==。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。和RPC非常相似，但是还是有一些细微差别



`不同:`

* HTTP规定了数据传输的格式，RPC可以任意指定。
* RPC在调用过程层面进行了API封装，HTTP需要自己去实现，只不过是浏览器帮我们实现了。
* RPC二进制传输，速度无敌，好在HTTP可以使用gzip进行压缩
* RPC实现难度高，HTTP较为友好并且更加灵活
* HTTP跨平台跨语言





> 微服务中，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于==Http的Rest风格服务==。





### HttpClient : JAVA

* 基于HTTP实现
* Apache旗下
* 封装了Java原生的网络编程中的(java.net.URL、java.net.URLConnection)。
* 支持HTTPS协议



`使用流程`

1. 创建 `HttpClient` 对象
2. 创建请求方法的实例，并指定请求 URL。如果需要发送 GET 请求，创建 `HttpGet` 对象；如果需要发送 POST 请求，创建 `HttpPost` 对象
3. 如果需要发送请求参数，可调用 `HttpGet`、`HttpPost` 共同的 `setParams(HttpParams params)` 方法来添加请求参数；对于 `HttpPost` 对象而言，也可调用 `setEntity(HttpEntity entity)` 方法来设置请求参数
4. 调用 `HttpClient` 对象的 `execute(HttpUriRequest request)` 发送请求，该方法返回一个 `HttpResponse`
5. 调用 `HttpResponse` 的 `getAllHeaders()`、`getHeaders(String name)` 等方法可获取服务器的响应头
6. 调用 `HttpResponse` 的 `getEntity()` 方法可获取 `HttpEntity` 对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容
7. 释放连接。无论执行方法是否成功，都必须释放连接



### RestTemplate : JAVA

* REST风格

* 是Spring-web项目中的一个Rest客户端
* 底层为httpclient封装
* 提供常见REST请求方案的模板，例如GET   POST    PUT   DELETE



### Feign ：JAVA

* REST风格

* HTTP轻量级框架
* 请求模板化
* 面向接口





## 服务注册中心

> 服务于服务之间是完全不透明的，如果使用固定IP去进行远程调用，那么对于系统的维护可想而知。甚至某些服务做成集群你又如何去负载均衡呢？服务注册中心可以帮我们更好地管理服务并且还监测服务的状态。

|                 | **Nacos**                  | **Eureka**  | **Consul**        | **CoreDNS** | **Zookeeper** |
| :-------------- | :------------------------- | :---------- | :---------------- | :---------- | :------------ |
| 一致性协议      | CP+AP                      | AP          | CP                | —           | CP            |
| 健康检查        | TCP/HTTP/MYSQL/Client Beat | Client Beat | TCP/HTTP/gRPC/Cmd | —           | Keep Alive    |
| 负载均衡策略    | 权重/ metadata/Selector    | Ribbon      | Fabio             | RoundRobin  | —             |
| 雪崩保护        | 有                         | 有          | 无                | 无          | 无            |
| 自动注销实例    | 支持                       | 支持        | 支持              | 不支持      | 支持          |
| 访问协议        | HTTP/DNS                   | HTTP        | HTTP/DNS          | DNS         | TCP           |
| 监听支持        | 支持                       | 支持        | 支持              | 不支持      | 支持          |
| 多数据中心      | 支持                       | 支持        | 支持              | 不支持      | 不支持        |
| 跨注册中心同步  | 支持                       | 不支持      | 支持              | 不支持      | 不支持        |
| SpringCloud集成 | 支持                       | 支持        | 支持              | 不支持      | 支持          |
| Dubbo集成       | 支持                       | 不支持      | 支持              | 不支持      | 支持          |
| K8S集成         | 支持                       | 不支持      | 支持              | 支持        | 不支持        |

> 从上图看出，Nacos 对于Java生态支持性更好.



## 配置中心

> 每个服务其实就是一个个单体spring项目，正常情况下，多个服务就对应多个配置文件，但是如果存在服务集群，位于维护的小伙伴们就不够友好，因此配置中心应用而生，用来集中管理服务中的配置信息。







## 服务熔断&服务降级

> 服务不可避免的会出现崩溃或者是网络崩溃，导致服务之间调用异常。针对于这种情况：
>
> * 服务熔断：当调用某个服务经常性失败，失败的次数达到某个阈值时，我们可以开启断路保护机制，后来的请求将不会掉用这个服务，本地直接返回默认数据或页面。
> * 服务降级：当系统处于高峰期，系统资源紧张，我们可以让非核心业务降级运行。即将非核心业务进行简单处理或者【抛异常、返回nul、调用Fallback处理逻辑l等等】









## API网关

> 对外暴露，并且可以请求拦截及处理、统一认证、限流流控、负载均衡、服务自动熔断、灰度发布、日志统计等丰富的功能